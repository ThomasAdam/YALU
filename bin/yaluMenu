#!/usr/bin/python
 ##############################################################################
################################################################################
####            YetAnotherLevelUp (YALU), an FVWM Configuration             ####
####               ~ Jonathan Heathcote                                     ####
####               ~ September 2009 - Present                               ####
####               ~ GNU GPLv3                                              ####
################################################################################
 ##############################################################################
#
# yaluMenu:
#   Generates dynamic menus for YALU and also facilitates setting options in the
#   config file. Syntax:
#      yaluMenu show [menu name]
#   or yaluMenu set [option] [value] | {[scope] [value]}

import sys, os, commands, re

################################################################################
# Configuration Management                                                     #
#   A class which wraps the various config methods used to store yalu settings #
################################################################################
# An option object -- on its own it does nothing
class Option:
	def __init__(self, config, default = ""):
		self.config = config
		self.default = default
	
	def getDefault(self):
		return self.default

# An option that configures an environment variable
class OptionEnvVar(Option):
	def __init__(self, variableName, *args, **params):
		Option.__init__(self, *args, **params)
		self.variableName = variableName
	
	def set(self, value):
		return self.config.setEnv(self.variableName, value)
	
	def get(self):
		return self.config.getEnv(self.variableName)

class Config:
	def __init__(self):
		# A dictionary of option objects for all configurable objects
		self.options = {
			"terminal": OptionEnvVar("yaluTerminal", self, "xterm")
		}
		
		# A variable that will store the config file (if it is loaded) in the form
		# of a list of lines in the file
		self.oldConfigFile = None
		self.config = None
	
	def __loadConfigFile(self):
		# Load the config file if neccesary
		if self.config == None:
			self.oldConfigFile = open("yaluConfig", "r").read()
			self.config = self.oldConfigFile.split("\n")
	
	def commit(self):
		# If the config file has been read...
		if self.config != None:
			# If the config has changed, save it
			currentConfigFile = "\n".join(self.config)
			if currentConfigFile != self.oldConfigFile:
				open("yaluConfig", "w").write(currentConfigFile)
	
	def setEnv(self, variableName, value):
		"""
		Set an environment variable both on the terminal, in the config file and
		print out an Fvwm command to set it
		"""
		self.__loadConfigFile()
		
		# The new line to be placed in the config file
		newConfigLine = "SetEnv %s \"%s\""%(variableName, value)
		
		# Monitor if a replacement has been made in the file
		replacementMade = False
		
		# Check each line of the file for the matching envvar and update it
		regex = "\s*SetEnv\s+%s.*"%(variableName,)
		for lineNumber, line in enumerate(self.config):
			match = re.match(regex, line, re.IGNORECASE)
			if match:
				self.config[lineNumber] = newConfigLine
				replacementMade = True
		
		# If no matches were found, add a replacement to the end along with a
		# comment
		if not replacementMade:
			self.config.append("# Added by yaluConfig")
			self.config.append(newConfigLine)
		
		# Set env variable for this terminal
		os.environ[variableName] = value
		
		# Return Fvwm command to set variable
		return newConfigLine
	
	def getEnv(self, variableName):
		try:
			return os.environ[variableName]
		except KeyError:
			return ""

################################################################################
# Menu Generation                                                              #
#   Classes which produce different menus for YALU                             #
################################################################################

# All Menu objects will be added to this dictionary with their names as the key
menus = {}

class Menu:
	def __init__(self, name, header = None, dynamic = False):
		"""
		A representation of an FVWM menu.
		
		name -- A string which will identify the menu uniquely
		header -- The string to display at the top of the menu as a heading
		dynamic -- Make this menu regenerate itself every time it is shown
		"""
		# Add this Menu object to the dictionary of all menus
		global menus
		menus[name] = self
		
		# Prevent changes once the menu has been rendered once
		self.locked = False
		
		# Store the name of the menu
		self.name = name
		
		# Destroy any previous menus of the same name
		self.fvwmCode = "DestroyMenu Recreate \"%s\"\n"%(self.name,)
		
		# If a header was supplied, add it to the menu
		if header != None:
			self.fvwmCode += "AddToMenu %s \"%s\" Title\n"%(self.name,header)
		
		# If the menu is dynamic bind the FVWM event to regenerate this menu
		if dynamic:
			self.fvwmCode += "AddToMenu %s DynamicPopupAction YaluMenu menu %s\n"%(
				self.name,
				self.name
			)
	
	def __str__(self):
		"""Return the FVWM Config data for this menu"""
		self.locked = True
		return self.fvwmCode
	
	def append(self, label = None, action = None, icon = None):
		"""Add a menu item to the menu, or, if nothing specified, a seperator"""
		# If the icon is present, give it an extension and propper eclosure.
		if not self.locked:
			if label != None:
				if icon != None:
					icon = "%%%s%%"%(icon,)
				else:
					icon = ""
				
				self.fvwmCode += "AddToMenu %s \"%s%s\" %s\n"%(
					self.name,
					icon,
					label.replace("\\","\\\\"),
					action
				)
			else:
				self.fvwmCode += "AddToMenu %s \"\" Nop\n"%(self.name, )
		else:
			raise Exception("Menu has been locked!")
	
	def appendProgram(self, label, command, bindHotkey=True):
		"""Add a program to the menu"""
		
		# Add a menu item with the specifed label and use the first word of the
		# command as the icon filename.
		self.append(label, "YaluExec %s"%(command,), command.partition(" ")[0])
		
		if bindHotkey:
			# If there is a specified hot key, use that
			hotkeyPosition = label.find("&") + 1
			if hotkeyPosition != 0 and hotkeyPosition < len(label):
				hotkey = label[hotkeyPosition]
				
				# Set up a keyboard shortcut for the menu entry (Super + Hotkey)
				self.fvwmCode += "Key %s A 4 YaluExec %s\n"%(hotkey, command)

class MenuLauncher(Menu):
	def __str__(self):
		"""Create a launcher"""
		# Add 'fixed' menu items first
		self.appendProgram("&Terminal", "$[yaluTerminal]")
		self.appendProgram("&Web Browser", "$[yaluBrowser]")
		self.appendProgram("&Editor", "$[yaluEditor]")
		self.append()
		
		# Load user's menu
		#   Format:
		#     * Entries seperated by lines
		#     * Entries can contain an ampersand to indicate a hotkey
		#     * Entries can be just a command
		#     * Entries can be a label and command seperated by a tab
		#     * Spaces can be added with a newline charachter
		for rawMenuData in open("menu","r").read().split("\n"):
			if rawMenuData == "":
				# Blank line: add a seperator
				self.append()
			elif rawMenuData.find("\t") != -1:
				# Tab-separated label and command
				label, _ , command = rawMenuData.partition("\t")
				self.appendProgram(label, command)
			else:
				# Command/Label are the same -- just strip the ampersands for the cmd
				label = rawMenuData
				command = rawMenuData.replace("&","")
				self.appendProgram(label, command)
		
		# Add a quit button
		self.append("Quit", "Quit", "quit")
		return Menu.__str__(self)

class MenuExecOutput(Menu):
	def __str__(self):
		"""Create Exec Output viewer menu"""
		# A list of screen sessions started by yalu
		sessions = []
		
		# Get a list of all screen sessions started by yalu
		for line in commands.getoutput("screen -ls").split("\n"):
			regex = r"\s*\d+[.]yalu_(\d+_\S+)"
			match = re.match(regex, line)
			if match:
				sessions.append(match.group(1))
		
		sessions.sort()
		
		# Add each session to the menu
		for session in sessions:
			pid, _ , name = session.partition("_")
			self.append(
				"%s (%s)"%(name, pid),
				"Exec exec $[yaluTerminal] -e \"screen -rx 'yalu_%s'\""%(session,),
				name
			)
		return Menu.__str__(self)

class MenuExecHistory(Menu):
	def __str__(self):
		"""Create a menu with recently/frequently used programs"""
		# Load the program history
		rawExecHistory = open("yaluExec_history", "r").read()
		
		# Strip out blank lines
		execHistory = []
		for line in rawExecHistory.split("\n"):
			if line.strip() != "":
				execHistory.append(line)
		
		if os.environ["yaluExecHistoryType"] == "recent":
			# Add appropriate title
			self.append("Recently Used Commands","Title")
			
			# Strip out contiguous repeats
			recentExecHistory = []
			lastItem = ""
			for item in execHistory:
				if item != lastItem:
					recentExecHistory.append(item)
					lastItem = item
			
			# Add the most recent 15 items to the menu
			self.appendTopEntries(recentExecHistory, 15)
		elif os.environ["yaluExecHistoryType"] == "frequent":
			# Add the title
			self.append("Frequently Used Commands","Title")
			
			# Only look at the most recent 100 entries
			recentExecHistory = self.__limitLast(execHistory, 100)
			
			# Count occurences
			execFrequency = [
				(x, recentExecHistory.count(x)) for x in set(recentExecHistory)
			]
			
			# Sort by occurences
			frequentExecHistory = sorted(execFrequency, key=lambda x: x[1])
			
			# Add them to the menu
			self.appendTopEntries([x[0] for x in frequentExecHistory], 15)
		
		# Add the "clear" option
		self.append()
		self.append("Clear History", "clearHistory", "delete")
		
		return Menu.__str__(self)
	
	def __limitLast(self, listToLimit, limit):
		limitedList = []
		for i in range(1,limit + 1):
			requiredIndex = len(listToLimit) - i
			if requiredIndex >= 0:
				limitedList.append(listToLimit[requiredIndex])
			else:
				break
		return limitedList
	
	def appendTopEntries(self, entryList, number):
		entryList = self.__limitLast(entryList, number)
		for entry in entryList:
			self.appendProgram(entry, entry, False)

if __name__ == "__main__":
	# Move into the YALU dir so that all paths from now on can be relative
	os.chdir(os.environ["YALU"])
	
	# Create a test menu
	test = Menu("test", "A Test Menu", True)
	test.append("Test Element","Nop", "xterm")
	
	config = Config()
	
	# Create a launcher
	MenuLauncher("launcher", "YetAnotherLevelUp", True)
	
	# Create an ExecOutput viewer
	MenuExecOutput("execOutput", "View Command Output", True)
	
	# Create the exec history menu
	MenuExecHistory("execHistory", None, True)
	
	
	sys.argv[0] = os.path.basename(sys.argv[0])
	if sys.argv[0] == "yaluMenu":
		if len(sys.argv) == 2:
			# Print the menu item specified as the second argument
			print menus[sys.argv[1]]
		else:
			for menu in menus:
				print menus[menu]
	elif sys.argv[0] == "yaluConfig":
		if len(sys.argv) == 2:
			# Just print the property
			option = config.options[sys.argv[1]]
			print "%s (Default: %s)"%(option.get(), option.getDefault())
		elif len(sys.argv) == 3:
			# Set the config value
			print config.options[sys.argv[1]].set(sys.argv[2])
		else:
			print "The following options are available:"
			for option in config.options:
				print option
	else:
		sys.stderr.write("ERROR: What command is this?\n")
	
	# Commit the options
	config.commit()
