#!/usr/bin/python
 ##############################################################################
################################################################################
####            YetAnotherLevelUp (YALU), an FVWM Configuration             ####
####               ~ Jonathan Heathcote                                     ####
####               ~ September 2009 - Present                               ####
####               ~ GNU GPLv3                                              ####
################################################################################
 ##############################################################################
#
# yaluMenu:
#   Generates dynamic menus for YALU. Syntax:
#      yaluMenu [menu name]
# yaluConfig:
#   Facilitates setting options in the config file. Syntax:
#      yaluConfig [option] [value] | {[scope] [value]}

import sys, os, commands, re

################################################################################
# Configuration Management                                                     #
#   A class which wraps the various config methods used to store yalu settings #
################################################################################
# An option object -- on its own it does nothing
class Option:
	def __init__(self, config, default = ""):
		self.config = config
		self.default = default
	
	def getDefault(self):
		return self.default

# An option that configures an environment variable
class OptionEnvVar(Option):
	def __init__(self, variableName, *args, **params):
		Option.__init__(self, *args, **params)
		self.variableName = variableName
	
	def set(self, value):
		self.config.setEnv(self.variableName, value)
	
	def get(self):
		return self.config.getEnv(self.variableName)

# An option that configures an environment variable that is used to set a style
class OptionEnvVarStyle(OptionEnvVar):
	def __init__(self, scope, *args, **params):
		OptionEnvVar.__init__(self, *args, **params)
		self.styleScope = scope
	
	def set(self, value):
		OptionEnvVar.set(self, value)
		# Update style
		self.config.FvwmCommand("Style %s %s"%(self.styleScope, value))

# An option that configures an environment variable and then executes a command
class OptionEnvVarCommand(OptionEnvVar):
	def __init__(self, command, *args, **params):
		OptionEnvVar.__init__(self, *args, **params)
		self.command = command
	
	def set(self, value):
		OptionEnvVar.set(self, value)
		# Run Command
		self.config.FvwmCommand(self.command)

class Config:
	def __init__(self):
		# A dictionary of option objects for all configurable objects
		self.options = {
			"terminal": OptionEnvVarCommand("YaluMenu", "yaluTerminal", self, "xterm"),
			"editor": OptionEnvVarCommand("YaluMenu", "yaluEditor", self, "gvim"),
			"browser": OptionEnvVarCommand("YaluMenu", "yaluBrowser", self, "firefox"),
			"execHistoryType": OptionEnvVar("yaluExecHistoryType", self, "frequent"),
			"placeMode": OptionEnvVarStyle("*", "yaluPlaceMode", self, "MinOverlapPlacement"),
			"snapDistance": OptionEnvVarCommand("setSnapDistance", "yaluSnapDistance", self, "10"),
			"focusMode": OptionEnvVarStyle("*", "yaluFocusMode", self, "MouseFocus"),
			"resizeCorner": OptionEnvVar("yaluResizeCorner", self, "WarpToWindow 100% 100%"),
			"desks": OptionEnvVarCommand("setDesks", "yaluDesks", self, "0"),
			"deskWidth": OptionEnvVarCommand("setPages", "yaluDeskWidth", self, "3"),
			"deskHeight": OptionEnvVarCommand("setPages", "yaluDeskHeight", self, "2"),
			"edgeJumpWidth": OptionEnvVarCommand("setEdgeJump", "yaluEdgeJumpWidth", self, "100"),
			"edgeJumpHeight": OptionEnvVarCommand("setEdgeJump", "yaluEdgeJumpHeight", self, "100"),
			"edgeResistDelay": OptionEnvVarCommand("setEdgeResistDelay", "yaluEdgeResistDelay", self, "0"),
		}
		
		# A variable that will store the config file (if it is loaded) in the form
		# of a list of lines in the file
		self.oldConfigFile = None
		self.config = None
	
	def __loadConfigFile(self):
		# Load the config file if neccesary
		if self.config == None:
			self.oldConfigFile = open("yaluConfig", "r").read()
			self.config = self.oldConfigFile.split("\n")
	
	def commit(self):
		# If the config file has been read...
		if self.config != None:
			# If the config has changed, save it
			currentConfigFile = "\n".join(self.config)
			if currentConfigFile != self.oldConfigFile:
				open("yaluConfig", "w").write(currentConfigFile)
	
	def setEnv(self, variableName, value):
		"""
		Set an environment variable both on the terminal, in the config file and
		print out an Fvwm command to set it
		"""
		self.__loadConfigFile()
		
		# The new line to be placed in the config file
		newConfigLine = "SetEnv %s \"%s\""%(variableName, value)
		
		# Monitor if a replacement has been made in the file
		replacementMade = False
		
		# Check each line of the file for the matching envvar and update it
		regex = "\s*SetEnv\s+%s.*"%(variableName,)
		for lineNumber, line in enumerate(self.config):
			match = re.match(regex, line, re.IGNORECASE)
			if match:
				self.config[lineNumber] = newConfigLine
				replacementMade = True
		
		# If no matches were found, add a replacement to the end along with a
		# comment
		if not replacementMade:
			self.config.append("# Added by yaluConfig")
			self.config.append(newConfigLine)
		
		# Set env variable for this terminal
		os.environ[variableName] = value
		
		# Send Fvwm command to set variable
		self.FvwmCommand(newConfigLine)
	
	def FvwmCommand(self, command):
		command = command.replace("\"","\\\"")
		commands.getoutput("FvwmCommand \"%s\""%("Echo " + command,))
		commands.getoutput("FvwmCommand \"%s\""%(command,))
	
	def getEnv(self, variableName):
		try:
			return os.environ[variableName]
		except KeyError:
			return ""

################################################################################
# Menu Generation                                                              #
#   Classes which produce different menus for YALU                             #
################################################################################

# All Menu objects will be added to this dictionary with their names as the key
menus = {}

class Menu:
	def __init__(self, name, header = None, dynamic = False):
		"""
		A representation of an FVWM menu.
		
		name -- A string which will identify the menu uniquely
		header -- The string to display at the top of the menu as a heading
		dynamic -- Make this menu regenerate itself every time it is shown
		"""
		# Add this Menu object to the dictionary of all menus
		global menus
		menus[name] = self
		
		# Prevent changes once the menu has been rendered once
		self.locked = False
		
		# Store the name of the menu
		self.name = name
		
		# Destroy any previous menus of the same name
		self.fvwmCode = "DestroyMenu Recreate \"%s\"\n"%(self.name,)
		
		# If a header was supplied, add it to the menu
		if header != None:
			self.fvwmCode += "AddToMenu %s \"%s\" Title\n"%(self.name,header)
		
		# If the menu is dynamic bind the FVWM event to regenerate this menu
		if dynamic:
			self.fvwmCode += "AddToMenu %s DynamicPopupAction YaluMenu menu %s\n"%(
				self.name,
				self.name
			)
	
	def __str__(self):
		"""Return the FVWM Config data for this menu"""
		self.locked = True
		return self.fvwmCode
	
	def append(self, label = None, action = None, icon = None):
		"""Add a menu item to the menu, or, if nothing specified, a seperator"""
		# If the icon is present, give it an extension and propper eclosure.
		if not self.locked:
			if label != None:
				if icon != None:
					icon = "%%%s%%"%(icon,)
				else:
					icon = ""
				
				self.fvwmCode += "AddToMenu %s \"%s%s\" %s\n"%(
					self.name,
					icon,
					str(label).replace("\\","\\\\"),
					action
				)
			else:
				self.fvwmCode += "AddToMenu %s \"\" Nop\n"%(self.name, )
		else:
			raise Exception("Menu has been locked!")
	
	def appendProgram(self, label, command, bindHotkey=True):
		"""Add a program to the menu"""
		
		# Add a menu item with the specifed label and use the first word of the
		# command as the icon filename.
		self.append(label, "YaluExec %s"%(command,), command.partition(" ")[0])
		
		if bindHotkey:
			# If there is a specified hot key, use that
			hotkeyPosition = label.find("&") + 1
			if hotkeyPosition != 0 and hotkeyPosition < len(label):
				hotkey = label[hotkeyPosition]
				
				# Set up a keyboard shortcut for the menu entry (Super + Hotkey)
				self.fvwmCode += "Key %s A 4 YaluExec %s\n"%(hotkey, command)

class MenuLauncher(Menu):
	def __str__(self):
		"""Create a launcher"""
		# Add 'fixed' menu items first
		self.appendProgram("&Terminal", os.environ["yaluTerminal"])
		self.appendProgram("&Web Browser", os.environ["yaluBrowser"])
		self.appendProgram("&Editor", os.environ["yaluEditor"])
		self.append()
		
		# Load user's menu
		#   Format:
		#     * Entries seperated by lines
		#     * Entries can contain an ampersand to indicate a hotkey
		#     * Entries can be just a command
		#     * Entries can be a label and command seperated by a tab
		#     * Spaces can be added with a newline charachter
		for rawMenuData in open("menu","r").read().split("\n"):
			if rawMenuData == "":
				# Blank line: add a seperator
				self.append()
			elif rawMenuData.find("\t") != -1:
				# Tab-separated label and command
				label, _ , command = rawMenuData.partition("\t")
				self.appendProgram(label, command)
			else:
				# Command/Label are the same -- just strip the ampersands for the cmd
				label = rawMenuData
				command = rawMenuData.replace("&","")
				self.appendProgram(label, command)
		
		# Add a quit button
		self.append("Quit", "Quit", "quit")
		return Menu.__str__(self)

class MenuExecOutput(Menu):
	def __str__(self):
		"""Create Exec Output viewer menu"""
		# A list of screen sessions started by yalu
		sessions = []
		
		# Get a list of all screen sessions started by yalu
		for line in commands.getoutput("screen -ls").split("\n"):
			regex = r"\s*\d+[.]yalu_(\d+_\S+)"
			match = re.match(regex, line)
			if match:
				sessions.append(match.group(1))
		
		sessions.sort()
		
		# Add each session to the menu
		for session in sessions:
			pid, _ , name = session.partition("_")
			self.append(
				"%s (%s)"%(name, pid),
				"Exec exec $[yaluTerminal] -e \"screen -rx 'yalu_%s'\""%(session,),
				name
			)
		return Menu.__str__(self)

class MenuExecHistory(Menu):
	def __str__(self):
		"""Create a menu with recently/frequently used programs"""
		# Load the program history
		rawExecHistory = open("yaluExec_history", "r").read()
		
		# Strip out blank lines
		execHistory = []
		for line in rawExecHistory.split("\n"):
			if line.strip() != "":
				execHistory.append(line)
		
		if os.environ["yaluExecHistoryType"] == "recent":
			# Add appropriate title
			self.append("Recently Used Commands","Title")
			
			# Strip out contiguous repeats
			recentExecHistory = []
			lastItem = ""
			for item in execHistory:
				if item != lastItem:
					recentExecHistory.append(item)
					lastItem = item
			
			# Add the most recent 15 items to the menu
			self.appendTopEntries(recentExecHistory, 15)
		elif os.environ["yaluExecHistoryType"] == "frequent":
			# Add the title
			self.append("Frequently Used Commands","Title")
			
			# Only look at the most recent 100 entries
			recentExecHistory = self.__limitLast(execHistory, 100)
			
			# Count occurences
			execFrequency = [
				(x, recentExecHistory.count(x)) for x in set(recentExecHistory)
			]
			
			# Sort by occurences
			frequentExecHistory = sorted(execFrequency, key=lambda x: x[1])
			
			# Add them to the menu
			self.appendTopEntries([x[0] for x in frequentExecHistory], 15)
		
		# Add the "clear" option
		self.append()
		self.append("Clear History", "clearExecHistory", "clearHistory")
		
		return Menu.__str__(self)
	
	def __limitLast(self, listToLimit, limit):
		limitedList = []
		for i in range(1,limit + 1):
			requiredIndex = len(listToLimit) - i
			if requiredIndex >= 0:
				limitedList.append(listToLimit[requiredIndex])
			else:
				break
		return limitedList
	
	def appendTopEntries(self, entryList, number):
		entryList = self.__limitLast(entryList, number)
		for entry in entryList:
			self.appendProgram(entry, entry, False)

class MenuRadioButtons(Menu):
	# The selected radio button
	selectedValue = ""
	
	# The default radio button
	defaultValue = ""
	
	# A template for the action to be performed on a button press where % is
	# substituded for the value
	buttonAction = ""
	
	def appendButton(self, label, value=None):
		if value == None:
			value = label
		
		# Choose an appropriate icon
		if str(value) == str(self.selectedValue):
			radioIcon = "radioButtonSel"
		else:
			radioIcon = "radioButtonNorm"
		
		if str(value) == self.defaultValue:
			label = str(label) + " (Default)"
		
		# Append button to the list
		self.append(label, self.buttonAction.replace("%", str(value)), radioIcon)

def makeYaluConfigRadioMenu(config, option, *args, **params):
	menu = MenuRadioButtons(*args, **params)
	menu.selectedValue = config.options[option].get()
	menu.defaultValue = config.options[option].getDefault()
	menu.buttonAction = "YaluConfig %s \"%%\""%(option,)
	return menu


if __name__ == "__main__":
	# Move into the YALU dir so that all paths from now on can be relative
	os.chdir(os.environ["LocalYALU"])
	
	# Create a test menu
	test = Menu("test", "A Test Menu", True)
	test.append("Test Element","Nop", "xterm")
	
	config = Config()
	
	# Create a launcher
	MenuLauncher("launcher", "YetAnotherLevelUp", True)
	
	# Create an ExecOutput viewer
	MenuExecOutput("execOutput", "View Command Output", True)
	
	# Create the exec history menu
	MenuExecHistory("execHistory", None, True)
	
	# Create the exec history config menu
	execHistoryConfig = makeYaluConfigRadioMenu(
		config, "execHistoryType", "execHistoryConfig", None, True
	)
	execHistoryConfig.appendButton("Frequently Used", "frequent")
	execHistoryConfig.appendButton("Recently Used", "recent")
	
	# Create the window placement config menu
	placeModeConfig = makeYaluConfigRadioMenu(
		config, "placeMode", "placeModeConfig", "Window Placement Mode", True
	)
	modes = [
		["Tile if possible, then cascade", "frequent"],
		["Tile if possible, then cascade", "TileCascadePlacement"],
		["Tile if possible, then manually place", "TileManualPlacement"],
		["Place all windows manually", "ManualPlacement"],
		["Tile with as little overlap as possible", "MinOverlapPlacement"],
		["Tile with as little % overlap as possible", "MinOverlapPercentPlacement"],
	]
	for label, value in modes:
		placeModeConfig.appendButton(label, value)
	
	# Create the window snapping config menu
	snapDistanceConfig = makeYaluConfigRadioMenu(
		config, "snapDistance", "snapDistanceConfig", "Window Snapping Distance", True
	)
	snapDistanceConfig.appendButton("Disabled", 0)
	distances = []
	distances.extend(range(2,6))
	distances.extend(range(10,26,5))
	distances.extend(range(50,201,25))
	for distance in distances:
		snapDistanceConfig.appendButton("%spx"%(distance,), distance)
	
	# Create the focus mode config menu
	focusModeConfig = makeYaluConfigRadioMenu(
		config, "focusMode", "focusModeConfig", "Window Focus Mode", True
	)
	modes = [
		["Click To Focus (Windows Style)", "ClickToFocus"],
		["Focus Follows Mouse (FVWM Style)", "MouseFocus"],
		["Sloppy Focus (X Style)", "SloppyFocus"],
	]
	for label, value in modes:
		focusModeConfig.appendButton(label, value)
	
	# Create the resize corner config menu
	resizeCornerConfig = makeYaluConfigRadioMenu(
		config, "resizeCorner", "resizeCornerConfig", "Alt-Resize Windows From...", True
	)
	modes = [
		["Cursor", ""],
		["Top-Left", "WarpToWindow 0% 0%"],
		["Top-Right", "WarpToWindow 100% 0%"],
		["Bottom-Left", "WarpToWindow 0% 100%"],
		["Bottom-Right", "WarpToWindow 100% 100%"],
	]
	for label, value in modes:
		resizeCornerConfig.appendButton(label, value)
	
	# Create the number-of-desks configuration menu
	desksConfig = makeYaluConfigRadioMenu(
		config, "desks", "desksConfig", "Number of Desks", True
	)
	for size in range(5):
		desksConfig.appendButton(size + 1, size)
	
	# Create the number-of-pages configuration menus
	for dimension in ["Width", "Height"]:
		deskPagesConfig = makeYaluConfigRadioMenu(
			config, "desk%s"%(dimension,),
			"desk%sConfig"%(dimension,), None, True
		)
		for size in range(1,10):
			deskPagesConfig.appendButton(size, size)
	
	# Create the jump-size configuration menus
	for dimension in ["Width", "Height"]:
		deskPagesConfig = makeYaluConfigRadioMenu(
			config, "edgeJump%s"%(dimension,),
			"edgeJump%sConfig"%(dimension,), None, True
		)
		deskPagesConfig.appendButton("Disabled", 0)
		for distance in range(10, 101,10):
			deskPagesConfig.appendButton("%s%%"%(distance,), distance)
	
	# Create the jump-delay configuration menu
	edgeResistDelay = makeYaluConfigRadioMenu(
		config, "edgeResistDelay", "edgeResistDelayConfig", "Delay by:", True
	)
	edgeResistDelay.appendButton("Instant", 0)
	for size in range(1,10):
		edgeResistDelay.appendButton("0.%ss"%(size,), size*100)
	
	sys.argv[0] = os.path.basename(sys.argv[0])
	if sys.argv[0] == "yaluMenu":
		if len(sys.argv) == 2:
			# Print the menu item specified as the second argument
			print menus[sys.argv[1]]
		else:
			for menu in menus:
				print menus[menu]
	elif sys.argv[0] == "yaluConfig":
		if len(sys.argv) == 2:
			# Just print the property
			option = config.options[sys.argv[1]]
			print "%s\nDefault: %s"%(option.get(), option.getDefault())
		elif len(sys.argv) == 3:
			# Set the config value
			config.options[sys.argv[1]].set(sys.argv[2])
		else:
			print "The following options are available:"
			for option in config.options:
				print option
	else:
		sys.stderr.write("ERROR: What command is this?\n")
	
	# Commit the options
	config.commit()
